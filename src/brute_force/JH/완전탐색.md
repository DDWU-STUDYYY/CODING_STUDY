### 완전탐색 

* 정의 : 알고리즘에서 사용되는 기법 중 하나로 모든 가능한 경우의 수를 탐색하여 최적의 결과를 찾는 방법을 의미한다. 

#### 종류 

1. 브루트 포스

정의 : 모든 경우의 수를 탐색하면서 원하는 결과를 얻는 알고리즘을 의미합니다. 

장점 : 가능한 모든 경우를 다 검사하기 때문에 예상된 결과를 얻을 수 있습니다. 

단점 : 경우의 수가 많을 경우 시간이 오래 걸리게 됩니다. 

2. 비트마스크 

정의 : 모든 경우의 수를 이진수로 표현하고 비트 연산을 통해 원하는 결과를 빠르게 얻는 알고리즘을 의미합니다. 

장점 : 이진수 연산을 이용하여 계산의 속도가 빠릅니다. 

단점 : 경우의 수가 많아질수록 메모리의 사용량이 늘어납니다. 

3. 백트래킹 

정의 : 결과를 얻기 위해 진행하는 도중에 막히게 되면 그 지점으로 다시 돌아가서 다른 경로를 탐색하는 방식을 의미합니다. 
결국 모든 가능한 경우의 수를 탐색하여 해결책을 찾습니다. 

장점 : 경우의 수를 줄이면서도 모든 경우를 탐색할 수 있습니다. 

단점 ; 재귀 함수를 이용하기 때문에 스택 오버플로우가 발생할 가능성이 있습니다. 


4. 순열 

정의 : 순열을 이용하여 모든 경우의 수를 탐색하는 방법입니다. 순열은 서로 다른 n개 중에서 r개를 선택하여 나열하는 방법을 의미합니다. 

장점 : 경우의 수가 적을 때 사용하면 유용합니다. 

단점 : 경우의 수가 많을 경우 시간이 오래 걸립니다. 

5. 재귀 함수 : 자기 자신을 호출하여 모든 가능한 경우의 수를 체크하면서 최적의 해답을 얻는 방식을 의미합니다. 

장점 : 코드가 간결하며 이해하기 쉽습니다. 

단점 : 스택 오버플로우가 발생할 가능성이 있습니다. 

6. DFS/BFS

정의 : 깊이 우선 탐색. 너비 우선 탐색. 

장점 : 미로 찾기 등에 유용합니다. 

단점 : 최악의 경우 모든 노드를 다 방문해야 하므로 시간이 오래 걸립니다. 

-----------

* 부르투 포스의 예시 

1. 배열 탐색 

```markdown

public static int findIndex(int[] arr, int target) {
    for(int i=0; i<arr.length; i++) {
         if(arr[i] ==target) {
            return i;
   }
}
  return -1;
}
```

2. 문자열 비교 

```markdown
public static int stringCompare(String s1, String s2) {
    int n1 = s1.length(), n2 = s2.length();
    int min = Math.min(n1,n2);

